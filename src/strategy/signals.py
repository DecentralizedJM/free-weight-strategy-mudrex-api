"""
Trading Signals
===============

Signal dataclasses and types for the strategy engine.
"""

from enum import Enum
from dataclasses import dataclass
from typing import Optional


class SignalType(Enum):
    """Signal direction type."""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"


@dataclass
class IndicatorStatus:
    """Status of individual indicators."""
    ema_bullish: bool = False
    ema_crossover: bool = False  # Fresh crossover this candle
    rsi_oversold: bool = False
    rsi_overbought: bool = False
    rsi_recovering: bool = False
    rsi_falling: bool = False
    macd_bullish: bool = False
    macd_crossover: bool = False  # Fresh crossover this candle
    macd_histogram_rising: bool = False
    oi_rising: bool = False
    oi_confirmation: str = "NEUTRAL"
    funding_sentiment: str = "NEUTRAL"
    funding_squeeze_risk: str = "NONE"


@dataclass
class Signal:
    """
    Trading signal generated by the strategy engine.
    
    Contains all information needed to execute a trade.
    """
    
    symbol: str
    signal_type: SignalType
    
    # Confidence and reasoning
    confluence_score: int  # 0-100
    indicators_aligned: int  # Number of aligned indicators (0-5)
    
    # Price levels
    entry_price: Optional[float] = None
    stoploss_price: Optional[float] = None
    takeprofit_price: Optional[float] = None
    
    # Trade parameters
    leverage: int = 5
    position_size_pct: float = 2.0  # % of capital
    
    # Metadata
    indicator_status: Optional[IndicatorStatus] = None
    reason: str = ""
    
    @property
    def is_actionable(self) -> bool:
        """Check if signal warrants action."""
        return self.signal_type in (SignalType.LONG, SignalType.SHORT)
    
    @property
    def is_long(self) -> bool:
        return self.signal_type == SignalType.LONG
    
    @property
    def is_short(self) -> bool:
        return self.signal_type == SignalType.SHORT
    
    @property
    def side(self) -> str:
        """Get side string for order placement."""
        if self.is_long:
            return "LONG"
        elif self.is_short:
            return "SHORT"
        return ""
    
    def to_dict(self) -> dict:
        """Convert signal to dictionary for logging."""
        return {
            "symbol": self.symbol,
            "type": self.signal_type.value,
            "confluence_score": self.confluence_score,
            "indicators_aligned": self.indicators_aligned,
            "entry_price": self.entry_price,
            "stoploss_price": self.stoploss_price,
            "takeprofit_price": self.takeprofit_price,
            "leverage": self.leverage,
            "position_size_pct": self.position_size_pct,
            "reason": self.reason,
        }
    
    def __str__(self) -> str:
        if not self.is_actionable:
            return f"Signal({self.symbol}: NEUTRAL)"
        
        return (
            f"Signal({self.symbol}: {self.signal_type.value} | "
            f"Score: {self.confluence_score}% | "
            f"Aligned: {self.indicators_aligned}/5 | "
            f"Entry: {self.entry_price:.2f} | "
            f"SL: {self.stoploss_price:.2f} | TP: {self.takeprofit_price:.2f})"
        )
